
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`include "header.sv"

module Toplevel_C5G_GPIO(

	//////////// CLOCK //////////
	input 		          		CLOCK_125_p,
	input 		          		CLOCK_50_B5B,
	input 		          		CLOCK_50_B6A,
	input 		          		CLOCK_50_B7A,
	input 		          		CLOCK_50_B8A,

	//////////// LED //////////
	output		     [7:0]		LEDG,
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		          		CPU_RESET_n,
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	output 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	logic 								rst_n;
	logic 								clk50m;
	logic [`DATA_W-1:0]				    light_data;
	logic [`ADDR_W-1:0] 				mem_addr;
    logic [`ADDR_W-1:0]                 addr_end;
	logic [`PRESCALE_W-1:0]			    prescale_value;
	logic                               button;
    logic                               button_press;
    logic                               button_correct;
    logic [7:0]                         count_value;
	logic [6:0]                         sevenseg0;
    logic [6:0]                         sevenseg1;



//=======================================================
//  Structural coding
//=======================================================
	assign rst_n					= CPU_RESET_n;
	assign clk50m					= CLOCK_50_B5B;
    assign prescale_value		    = {SW, {(`PRESCALE_W-10){1'b0}}};
    assign button                   = KEY[0];
	
	
	assign LEDR						= light_data;
	assign LEDG						= '0;
	assign HEX0						= sevenseg0;
	assign HEX1						= sevenseg1;
	assign GPIO						= '0;


	
	addr_control		u1_addr_control(
		 .rst_n,
		 .clk50m,
		 .prescale		(prescale_value),
         .addr_end      (addr_end),
		 .addr			(mem_addr)
	);

	memory_ip u1_memory_ip(
		.address		(mem_addr),
		.clock			(clk50m),
		.q				(light_data)
    );
    
    addr_end_ip u1_addr_end_ip(
        .result         (addr_end)
    );
	
	edge_detect u1_edge_detect(
        .rst_n,
        .clk50m,
        .in             (button),
        .risingedge     (),
        .fallingedge    (button_press)
    );
    
    assign          button_correct = ( button_press && light_data[5] );
    
    upcounter       u1_upcounter(
        .rst_n,
        .clk50m,
        .enable         (button_correct),
        .count          (count_value)
    );
    
    sevenseg                u0_sevenseg(
        .bin                (count_value[3:0]),
        .sevenseg           (),
        .sevenseg_n         (sevenseg0)
    );
    sevenseg                u1_sevenseg(
        .bin                (count_value[7:4]),
        .sevenseg           (),
        .sevenseg_n         (sevenseg1)
    );

endmodule
